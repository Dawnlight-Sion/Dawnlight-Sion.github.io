<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="诗音"><meta name="copyright" content="诗音"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>蓝桥杯真题综述 | 晨曦辉月</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/magic_32px.ico"><link rel="mask-icon" href="/magic_32px.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://gitee.com" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"dawnlight-sion.github.io","root":"/","title":"晨曦辉月","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="字串排序问题描述小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。 在冒泡排序中，每次只能交换相邻的两个元素。 小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。 例如，对于字符串 lan 排序，只需要 1 次交换。对于字符串 qiao 排序，总共需要 4 次交换。 小蓝的幸运数字是 V，他想找到一个只包含小写英文字母的字">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝桥杯真题综述">
<meta property="og:url" content="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/index.html">
<meta property="og:site_name" content="晨曦辉月">
<meta property="og:description" content="字串排序问题描述小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。 在冒泡排序中，每次只能交换相邻的两个元素。 小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。 例如，对于字符串 lan 排序，只需要 1 次交换。对于字符串 qiao 排序，总共需要 4 次交换。 小蓝的幸运数字是 V，他想找到一个只包含小写英文字母的字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lx.lanqiao.cn/RequireFile.do?fid=aXdGND5B">
<meta property="og:image" content="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/image-20210524195919662.png">
<meta property="og:image" content="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA.png">
<meta property="og:image" content="http://lx.lanqiao.cn/RequireFile.do?fid=b6V96pY6">
<meta property="og:image" content="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/%E5%AD%97%E4%B8%B21.png">
<meta property="og:image" content="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/%E5%AD%97%E4%B8%B22.png">
<meta property="og:image" content="http://lx.lanqiao.cn/RequireFile.do?fid=H549d7Ej">
<meta property="article:published_time" content="2021-05-30T00:55:00.000Z">
<meta property="article:modified_time" content="2021-05-30T02:28:28.000Z">
<meta property="article:author" content="诗音">
<meta property="article:tag" content="C++竞赛题解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lx.lanqiao.cn/RequireFile.do?fid=aXdGND5B"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="诗音"><img width="96" loading="lazy" src="/avatar.jpg" alt="诗音"></a><div class="site-author-name"><a href="/about/">诗音</a></div><a class="site-name" href="/about/site.html">晨曦辉月</a><sub class="site-subtitle"></sub><div class="site-desciption">真理永恒</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">121</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Dawnlight-Sion" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">字串排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5"><span class="toc-number">1.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1"><span class="toc-number">1.6.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="toc-number">1.7.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.8.</span> <span class="toc-text">评测用例规模与约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D"><span class="toc-number">1.9.</span> <span class="toc-text">方法：搜索+剪枝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8D%92%E5%B2%9B%E6%8E%A2%E6%B5%8B"><span class="toc-number">2.</span> <span class="toc-text">荒岛探测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">2.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">2.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-2"><span class="toc-number">2.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-2"><span class="toc-number">2.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.6.</span> <span class="toc-text">样例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A-1"><span class="toc-number">2.7.</span> <span class="toc-text">评测用例规模与约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-number">2.8.</span> <span class="toc-text">方法：计算几何</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%88%87%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">平面切分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">3.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">3.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-3"><span class="toc-number">3.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-3"><span class="toc-number">3.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A-2"><span class="toc-number">3.6.</span> <span class="toc-text">评测用例规模与约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">3.7.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E7%8F%A0"><span class="toc-number">4.</span> <span class="toc-text">装饰珠</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">4.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">4.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-4"><span class="toc-number">4.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-4"><span class="toc-number">4.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="toc-number">4.6.</span> <span class="toc-text">样例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A-3"><span class="toc-number">4.7.</span> <span class="toc-text">评测用例规模与约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text">方法：0-1背包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">回文日期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">5.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-4"><span class="toc-number">5.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-4"><span class="toc-number">5.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-5"><span class="toc-number">5.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-5"><span class="toc-number">5.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A-4"><span class="toc-number">5.6.</span> <span class="toc-text">评测用例规模与约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">5.7.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">5.8.</span> <span class="toc-text">代码：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%89%A9%E6%9D%82%E4%BA%A4"><span class="toc-number">6.</span> <span class="toc-text">作物杂交</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">6.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-5"><span class="toc-number">6.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-5"><span class="toc-number">6.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-6"><span class="toc-number">6.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-6"><span class="toc-number">6.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%AF%B4%E6%98%8E-2"><span class="toc-number">6.6.</span> <span class="toc-text">样例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E7%94%A8%E4%BE%8B%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A-5"><span class="toc-number">6.7.</span> <span class="toc-text">评测用例规模与约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.8.</span> <span class="toc-text">思路：动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2"><span class="toc-number">6.9.</span> <span class="toc-text">思路2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">7.</span> <span class="toc-text">数字三角形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">7.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-6"><span class="toc-number">7.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-6"><span class="toc-number">7.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-7"><span class="toc-number">7.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-7"><span class="toc-number">7.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">7.6.</span> <span class="toc-text">代码思路：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2%E5%88%86%E5%80%BC%E5%92%8C"><span class="toc-number">8.</span> <span class="toc-text">子串分值和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E6%A0%B9%E6%A4%8D%E7%89%A9"><span class="toc-number">9.</span> <span class="toc-text">合根植物</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">9.1.</span> <span class="toc-text">资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-7"><span class="toc-number">9.2.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-7"><span class="toc-number">9.3.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-8"><span class="toc-number">9.4.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-8"><span class="toc-number">9.5.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%AF%B4%E6%98%8E-3"><span class="toc-number">9.6.</span> <span class="toc-text">样例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">9.7.</span> <span class="toc-text">基本思路：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E8%80%83%E5%9C%BA"><span class="toc-number">10.</span> <span class="toc-text">分考场</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6-1"><span class="toc-number">10.1.</span> <span class="toc-text">资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-8"><span class="toc-number">10.2.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-8"><span class="toc-number">10.3.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-7"><span class="toc-number">10.4.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-9"><span class="toc-number">10.5.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-9"><span class="toc-number">10.6.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-10"><span class="toc-number">10.7.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-10"><span class="toc-number">10.8.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%92-%E6%9A%B4%E5%8A%9B%E7%AE%80%E5%8C%96%E7%89%88"><span class="toc-number">10.9.</span> <span class="toc-text">规划+暴力简化版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">10.9.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%80%E5%8C%96%E7%89%88"><span class="toc-number">10.10.</span> <span class="toc-text">递归简化版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">10.10.1.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%AC%ACn%E4%BD%8D"><span class="toc-number">11.</span> <span class="toc-text">小数第n位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6-2"><span class="toc-number">11.1.</span> <span class="toc-text">资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-9"><span class="toc-number">11.2.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-9"><span class="toc-number">11.3.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-8"><span class="toc-number">11.4.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-11"><span class="toc-number">11.5.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-11"><span class="toc-number">11.6.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-12"><span class="toc-number">11.7.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-12"><span class="toc-number">11.8.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-13"><span class="toc-number">11.9.</span> <span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-13"><span class="toc-number">11.10.</span> <span class="toc-text">样例输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">11.11.</span> <span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%82%E5%85%89%E9%93%81%E8%B7%AF"><span class="toc-number">12.</span> <span class="toc-text">观光铁路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">12.1.</span> <span class="toc-text">并没有解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E5%B1%80%E5%8C%B9%E9%85%8D"><span class="toc-number">13.</span> <span class="toc-text">对局匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%B4%AA%E5%BF%83"><span class="toc-number">13.1.</span> <span class="toc-text">思路：贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-dp"><span class="toc-number">13.2.</span> <span class="toc-text">题解:dp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E7%8E%AF"><span class="toc-number">14.</span> <span class="toc-text">发现环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">14.1.</span> <span class="toc-text">解题思路：拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E7%A7%BB%E4%BD%8D"><span class="toc-number">15.</span> <span class="toc-text">区间移位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">15.1.</span> <span class="toc-text">解析：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9A%E6%B3%95%EF%BC%9A"><span class="toc-number">15.2.</span> <span class="toc-text">做法：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A1%AB%E5%AD%97%E6%AF%8D%E6%B8%B8%E6%88%8F"><span class="toc-number">16.</span> <span class="toc-text">填字母游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8D%9A%E5%BC%88%E6%A0%91"><span class="toc-number">16.1.</span> <span class="toc-text">方法：博弈树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">16.2.</span> <span class="toc-text">方法：博弈论</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="诗音"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="晨曦辉月"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">蓝桥杯真题综述</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-05-30 08:55:00" itemprop="dateCreated datePublished" datetime="2021-05-30T08:55:00+08:00">2021-05-30</time></div><div class="post-classify"><span class="post-tag"><a class="tag" href="/tags/C-%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">C++竞赛题解</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="字串排序"><a href="#字串排序" class="headerlink" title="字串排序"></a>字串排序</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。</p>
<p>在冒泡排序中，每次只能交换相邻的两个元素。</p>
<p>小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。</p>
<p>例如，对于字符串 <code>lan</code> 排序，只需要 1 次交换。对于字符串 <code>qiao</code> 排序，总共需要 4 次交换。</p>
<p>小蓝的幸运数字是 V，他想找到一个只包含小写英文字母的字符串，对这个串中的字符进行冒泡排序，正好需要 V 次交换。请帮助小蓝找一个这样的字符串。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。请注意字符串中可以包含相同的字符。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行包含一个整数 V，为小蓝的幸运数字。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个字符串，为所求的答案。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bbaa</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jihgfeeddccbbaa</span><br></pre></td></tr></table></figure>

<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 30% 的评测用例，1≤V≤20。</p>
<p>对于 50% 的评测用例，1≤V≤100。</p>
<p>对于所有评测用例，1≤V≤10000。</p>
<h2 id="方法：搜索-剪枝"><a href="#方法：搜索-剪枝" class="headerlink" title="方法：搜索+剪枝"></a>方法：搜索+剪枝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], res[N];</span><br><span class="line"><span class="keyword">int</span> n, m, _max, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> letter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">26</span>, j = letter;</span><br><span class="line">	<span class="keyword">while</span> (!res[i]) i--;</span><br><span class="line">	<span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (res[i] != num[j]) &#123;</span><br><span class="line">				<span class="keyword">return</span> res[i] &gt; num[j];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				i--; j--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> letter, <span class="keyword">int</span> curlen, <span class="keyword">int</span> cursum, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cursum &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (letter &gt; _max) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (curlen &gt; len) <span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (curlen == len &amp;&amp; cursum != n) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (letter == _max &amp;&amp; cursum != n) <span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cursum == n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (curlen &lt; len || <span class="built_in">judge</span>(letter)) &#123; <span class="comment">//长度减小或字典序减小更新结果</span></span><br><span class="line">			len = curlen;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">				res[i] = num[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) &#123;</span><br><span class="line">		num[letter + <span class="number">1</span>] = i;</span><br><span class="line">		<span class="built_in">dfs</span>(letter + <span class="number">1</span>, curlen + i, cursum + i * curlen, i);</span><br><span class="line">	&#125;</span><br><span class="line">	num[letter + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	m = <span class="number">0</span>; len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">26</span>; i++) &#123; <span class="comment">//找到s最小的点, 如果存在多个取字典序更小的</span></span><br><span class="line">      <span class="keyword">if</span> (res[i] &lt; res[id]) id = i;</span><br><span class="line">		&#125;</span><br><span class="line">		m += len - res[id];</span><br><span class="line">		_max = <span class="built_in">max</span>(_max, id);</span><br><span class="line">		len ++; res[id] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = _max; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = res[i]; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i<span class="number">-1</span>+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="荒岛探测"><a href="#荒岛探测" class="headerlink" title="荒岛探测"></a>荒岛探测</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>科学家小蓝来到了一个荒岛，准备对这个荒岛进行探测考察。</p>
<p>小蓝使用了一个超声定位设备来对自己进行定位。为了使用这个设备，小蓝需要在不同的点分别安装一个固定的发射器和一个固定的接收器。小蓝手中还有一个移动设备。定位设备需要从发射器发射一个信号到移动设备，移动设备收到后马上转发，最后由接收器接收，根据这些设备之间传递的时间差就能计算出移动设备距离发射器和接收器的两个距离，从而实现定位。</p>
<p>小蓝在两个位置已经安装了发射器和接收器，其中发射器安装在坐标 (xA,yA)，接收器安装在坐标 (xB,yB)。小蓝的发射器和接收器可能在岛上，也可能不在岛上。</p>
<p>小蓝的定位设备设计有些缺陷，当发射器到移动设备的距离加上移动设备到接收器的距离之和大于 L 时，定位设备工作不正常。当和小于等于 L 时，定位设备工作正常。为了安全，小蓝只在定位设备工作正常的区域探测考察。</p>
<p>已知荒岛是一个三角形，三个顶点的坐标分别为 (x1,y1), (x2,y2), (x3,y3)。</p>
<p>请计算，小蓝在荒岛上可以探测到的面积有多大？</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含五个整数，分别为 xA, yA, xB, yB, L。</p>
<p>第二行包含六个整数，分别为 x1, y1, x2, y2, x3, y3。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。</p>
<p>考虑到计算中的误差，只要你的输出与参考输出相差不超过 0.01 即可得分。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 6 4 12 12</span><br><span class="line">0 2 13 2 13 15</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">39.99</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>荒岛的形状和定位设备工作正常的区域如下图所示，蓝色的三角形表示荒岛，红色的曲线围成的区域为定位设备工作正常的区域。</p>
<p><img src="http://lx.lanqiao.cn/RequireFile.do?fid=aXdGND5B" alt="island.png" loading="lazy"></p>
<p>当输出为 39.98、39.99 或 40.00 时可以得分。</p>
<h2 id="评测用例规模与约定-1"><a href="#评测用例规模与约定-1" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有评测用例，保证发射器的两个坐标不同，−1000≤xA,yA,xB,yB≤1000, −1000≤x1,y1,x2,y2,x3,y3≤1000, −1000≤L≤1000。</p>
<h2 id="方法：计算几何"><a href="#方法：计算几何" class="headerlink" title="方法：计算几何"></a>方法：计算几何</h2><p>解题思路<br>因为前不久刚好做了一道扫描线的题，所有比较容易想到用扫描线来做。题目的目的是求椭圆与三角行的相交部分的面积，解题大致思路就是用一条平行于y轴的直线设为xi，每次xi+0.001（本来估算+0.01的，不过测试时发现+0.001运行时间也是0毫秒，就干脆提高一点精度了），然后像积分那样将面积分成一个一个小矩形一点一点加起来。计算三角形和椭圆重叠部分面积等价于计算，所有相同xi下三角形里分割出的矩形与椭圆里分割出的矩形重叠面积之和如下图</p>
<p>所有x1下像图中椭圆浅粉色矩形与三角形灰蓝色重叠部分之和，就是我们要的答案了。<br>在有解情况下x=xi时，三角形与直线x=xi可以得到两个解y1,y2(y1&lt;=y2)，椭圆同理可得y3,y4(y3&lt;=y4)，如果min(y2,y4)&gt;max(y1,y3) ,总面积sum就加上（min(y2,y4)-max(y1,y3) ）* 0.001 （0.001是所选的精度）。三角形的y1,y2，计算比较简单，算三条直线即可。椭圆就比较麻烦了，毕竟高中只学过焦点所在直线在坐标轴上焦点的中点在坐标原点的，我先试了一下直接解方程</p>
<p><img src="/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/image-20210524195919662.png" alt="image-20210524195919662" loading="lazy"></p>
<p>刚开始以为解这个方程很难就没有去算。。。写着写着博客感觉这就是两个平方的事。。。 觉得下面方法不合适自己的话可以尝试解方程，下面我讲一讲另一种方法：<br>由于只学过上述的那种椭圆，所以我的想法就是把二维坐标移动到自己想要的位置即可，即以椭圆中心为原点，焦点所在直线为x轴，其他的坐标同时更新,则椭圆方程为x2/a2+y2/b2=1。然后用椭圆准线(x=+a2/c,x=-a2/c)的性质(椭圆上的点到准线的距离比上该点到对应焦点的距离等于离心率a/c) ，再用上勾股定理就可以求对应的y值</p>
<h1 id="平面切分"><a href="#平面切分" class="headerlink" title="平面切分"></a>平面切分</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>平面上有 N 条直线，其中第 i 条直线是 y=Ai⋅x+Bi。</p>
<p>请计算这些直线将平面分成了几个部分。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 N。</p>
<p>以下N行，每行包含两个整数 Ai,Bi。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数代表答案。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="评测用例规模与约定-2"><a href="#评测用例规模与约定-2" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 50 的评测用例，1≤N≤4, −10≤Ai,Bi≤10。</p>
<p>对于所有评测用例，1≤N≤1000, −100000≤Ai,Bi≤100000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>画几张图观察一下可以发现一下特点：</p>
<p>1、重边不会影响区域数目。<br>2、每新加入一条边只要不是重边区域数目必定+1。<br>3、加入的新边如果与之前加入的边每有一个交点则区域数目+1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; line;<span class="comment">//存放直线信息</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> c, d;</span><br><span class="line">	pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; inter;</span><br><span class="line">	set&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; point;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : line) &#123;</span><br><span class="line">		c = it.first, d = it.second;</span><br><span class="line">		<span class="keyword">if</span> (c != a) &#123;</span><br><span class="line"></span><br><span class="line">			inter.first = (d - b) / (a - c);</span><br><span class="line">			inter.second = a*inter.first + b;</span><br><span class="line"></span><br><span class="line">			point.<span class="built_in">insert</span>(inter);<span class="comment">//存放新的直线与其余直线的交点</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	ans += point.<span class="built_in">size</span>();<span class="comment">//每有一个点区域数量+1</span></span><br><span class="line">	point.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">int</span> l = line.<span class="built_in">size</span>();</span><br><span class="line">		line.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">size</span>() != l) &#123;<span class="comment">//重边不会影响平面数目</span></span><br><span class="line">			ans++;<span class="comment">//无论什么情况只要不是重边，加入新的直线后区域数量无条件+1</span></span><br><span class="line">			<span class="built_in">compute</span>(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="装饰珠"><a href="#装饰珠" class="headerlink" title="装饰珠"></a>装饰珠</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>在怪物猎人这一款游戏中，玩家可以通过给装备镶嵌不同的装饰珠来获取相应的技能，以提升自己的战斗能力。</p>
<p>已知猎人身上一共有 6 件装备，每件装备可能有若干个装饰孔，每个装饰孔有各自的等级，可以镶嵌一颗小于等于自身等级的装饰珠(也可以选择不镶嵌)。</p>
<p>装饰珠有 M 种，编号 1 至 M，分别对应 M 种技能，第 i 种装饰珠的等级为 Li，只能镶嵌在等级大于等于 Li 的装饰孔中。</p>
<p>对第 i 种技能来说，当装备相应技能的装饰珠数量达到 Ki 个时，会产生 Wi(Ki) 的价值。镶嵌同类技能的数量越多，产生的价值越大，即 Wi(Ki−1)&lt;Wi(Ki)。但每个技能都有上限 Pi(1≤Pi≤7)，当装备的珠子数量超过 Pi 时，只会产生 Wi(Pi) 的价值。</p>
<p>对于给定的装备和装饰珠数据，求解如何镶嵌装饰珠，使得 6 件装备能得到的总价值达到最大。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第 1 至 6 行，包含 6 件装备的描述。其中第 i 的第一个整数 Ni 表示第 i 件装备的装饰孔数量。后面紧接着 Ni 个整数，分别表示该装备上每个装饰孔的等级 L(1≤L≤4)。</p>
<p>第 7 行包含一个正整数 M，表示装饰珠(技能)种类数量。</p>
<p>第 8 至 M+7 行，每行描述一种装饰珠(技能)的情况。每行的前两个整数 Lj(1≤Lj≤4) 和 Pj(1≤Pj≤7) 分别表示第 j 种装饰珠的等级和上限。接下来 Pj 个整数，其中第 k 个数表示装备该中装饰珠数量为 k 时的价值 Wj(k)。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行包含一个整数，表示能够得到的最大价值。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 1 2</span><br><span class="line">1 1</span><br><span class="line">2 2 2</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">3</span><br><span class="line">1 5 1 2 3 5 8</span><br><span class="line">2 4 2 4 8 15</span><br><span class="line">3 2 5 10</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h2><p>按照如下方式镶嵌珠子得到最大价值 20，括号内表示镶嵌的装饰珠的种类编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: (1)</span><br><span class="line">2: (1) (2)</span><br><span class="line">3: (1)</span><br><span class="line">4: (2) (2)</span><br><span class="line">5: (1)</span><br><span class="line">6: (2)</span><br></pre></td></tr></table></figure>

<p>None</p>
<p>4 颗技能 1 装饰珠，4 颗技能 2 装饰珠 W1(4)+W2(4)=5+15=20。</p>
<h2 id="评测用例规模与约定-3"><a href="#评测用例规模与约定-3" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 30 的评测用例，1≤Ni≤10, 1≤M≤20, 1≤Wj(k)≤500；</p>
<p>对于所有评测用例，1≤Ni≤50, 1≤M≤10000, 1≤Wj(k)≤10000。</p>
<p><img src="/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/%E6%80%AA%E7%89%A9%E7%8C%8E%E4%BA%BA.png" alt="怪物猎人.png" loading="lazy"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aLgorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> MAXN = <span class="number">55</span>, MAXS = <span class="number">305</span>, MAXM = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n[MAXN], cnt[<span class="number">5</span>], Lv[MAXM], p[MAXM], w[MAXM][MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXM][MAXS];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; n[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= n[i]; j++) &#123; cin &gt;&gt; x; cnt[x]++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Lv[i] &gt;&gt; p[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[i]; j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x80</span>, <span class="keyword">sizeof</span> dp), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">4</span>; L &gt;= <span class="number">1</span>; L--) &#123;</span><br><span class="line">        sum += cnt[L];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">if</span> (Lv[i] == L) &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= sum; k++)</span><br><span class="line">                    dp[tot][k] = dp[tot - <span class="number">1</span>][k];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[i]; j++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= sum; k++)</span><br><span class="line">                        dp[tot][k] = <span class="built_in">max</span>(dp[tot][k], dp[tot - <span class="number">1</span>][k - j] + w[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sum; i++) ans = <span class="built_in">max</span>(ans, dp[tot][i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Read</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法：0-1背包问题"><a href="#方法：0-1背包问题" class="headerlink" title="方法：0-1背包问题"></a>方法：0-1背包问题</h2><h1 id="回文日期"><a href="#回文日期" class="headerlink" title="回文日期"></a>回文日期</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>2020年春节期间，有一个特殊的日期引起了大家的注意：2020年2月2日。因为如果将这个日期按 <code>yyyymmdd</code> 的格式写成一个8位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。</p>
<p>有人表示 20200202 是“千年一遇”的特殊日子。对此小明很不认同，因为不到2年之后就是下一个回文日期：20211202 即2021年12月2日。</p>
<p>也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即2121年12月12日。算不上“千年一遇”，顶多算“千年两遇”。</p>
<p>给定一个8位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。</p>
<h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一个八位整数 N，表示日期。</p>
<h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出两行，每行1个八位数。<br>第一行表示下一个回文日期，第二行表示下一个 ABABBABA 型的回文日期。</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20200202</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20211202</span><br><span class="line">21211212</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="评测用例规模与约定-4"><a href="#评测用例规模与约定-4" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有评测用例，10000101≤N≤89991231， 保证 N 是一个合法日期的 8 位数表示。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>直接按照题意模拟，暴力判断。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Date: 2020-10-18 13:13:44</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-11-24 14:41:52</span></span><br><span class="line"><span class="comment"> * @Author&#x27;s blog: blog.nuoyanli.com</span></span><br><span class="line"><span class="comment"> * @Description: Plum blossom from the bchter cold!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> temp[<span class="number">10</span>], m[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hw</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    temp[tot++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp[i] != temp[tot - i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> year = x / <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">int</span> month = temp[<span class="number">3</span>] * <span class="number">10</span> + temp[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> day = temp[<span class="number">1</span>] * <span class="number">10</span> + temp[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ((year % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; year % <span class="number">4</span> == <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (month &gt; <span class="number">12</span> || month &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (day &gt; m[month]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">int</span> ans1, ans2;</span><br><span class="line">  <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hw</span>(i)) &#123;      <span class="comment">//判断回文</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123; <span class="comment">//判断合法</span></span><br><span class="line">        ans1 = i;</span><br><span class="line">        <span class="keyword">if</span> (temp[<span class="number">0</span>] == temp[<span class="number">2</span>] &amp;&amp; temp[<span class="number">2</span>] == temp[<span class="number">5</span>] &amp;&amp; temp[<span class="number">5</span>] == temp[<span class="number">7</span>] &amp;&amp;</span><br><span class="line">            temp[<span class="number">1</span>] == temp[<span class="number">3</span>] &amp;&amp; temp[<span class="number">3</span>] == temp[<span class="number">4</span>] &amp;&amp; temp[<span class="number">4</span>] == temp[<span class="number">6</span>]) &#123;</span><br><span class="line">          ans2 = i;</span><br><span class="line">          f = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!f) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ans1 + <span class="number">1</span>; i &lt;= <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">hw</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp[<span class="number">0</span>] == temp[<span class="number">2</span>] &amp;&amp; temp[<span class="number">2</span>] == temp[<span class="number">5</span>] &amp;&amp; temp[<span class="number">5</span>] == temp[<span class="number">7</span>] &amp;&amp;</span><br><span class="line">              temp[<span class="number">1</span>] == temp[<span class="number">3</span>] &amp;&amp; temp[<span class="number">3</span>] == temp[<span class="number">4</span>] &amp;&amp; temp[<span class="number">4</span>] == temp[<span class="number">6</span>]) &#123;</span><br><span class="line">            ans2 = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, ans1, ans2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="作物杂交"><a href="#作物杂交" class="headerlink" title="作物杂交"></a>作物杂交</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h2><p>作物杂交是作物栽培中重要的一步。已知有 N 种作物(编号 1 至 N )，第 i 种作物从播种到成熟的时间为 Ti。<br>作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。<br>作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。</p>
<p>初始时，拥有其中 M 种作物的种子(数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。<br>求问对于给定的目标种子，最少需要多少天能够得到。</p>
<p>如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A×B→C，A×C→D。<br>则最短的杂交过程为：</p>
<p>第 1 天到第 7 天(作物 B 的时间)，A×B→C。</p>
<p>第 8 天到第 12 天(作物 A 的时间)，A×C→D。</p>
<p>花费 12 天得到作物 D 的种子。</p>
<h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第 1 行包含 4 个整数 N,M,K,T，N 表示作物种类总数(编号 1 至 N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。</p>
<p>第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间 Ti(1≤Ti≤100)。</p>
<p>第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj(1≤Kj≤M)，Kj 两两不同。</p>
<p>第 4 至 K+3 行，每行包含 3 个整数 A,B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。</p>
<h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示得到目标种子的最短杂交时间。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 2 4 6</span><br><span class="line">5 3 4 6 4 9</span><br><span class="line">1 2</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 5</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例说明-2"><a href="#样例说明-2" class="headerlink" title="样例说明"></a>样例说明</h2><p>第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。</p>
<p>第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。</p>
<p>第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。</p>
<p>第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。</p>
<p>总共花费 16 天。</p>
<h2 id="评测用例规模与约定-5"><a href="#评测用例规模与约定-5" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于所有评测用例，1≤N≤2000, 2≤M≤N, 1≤K≤100000, 1≤T≤N, 保证目标种子一定可以通过杂交得到。</p>
<h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p> 创建一个DP数组，存储获得每个种子所需的最短时间，用dfs遍历每个能获得目标种子的方案，不断更新dp数组获得最短时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">inf = <span class="number">1e9</span></span><br><span class="line">def <span class="built_in">dfs</span>(a,b,tar):</span><br><span class="line">    <span class="keyword">if</span> k[a] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> each in plan[a]:</span><br><span class="line">            dp[a] = <span class="built_in">min</span>(dp[a],<span class="built_in">dfs</span>(each[<span class="number">0</span>],each[<span class="number">1</span>],a))</span><br><span class="line">    <span class="keyword">if</span> k[b] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> each in plan[b]:</span><br><span class="line">            dp[b] = <span class="built_in">min</span>(dp[b],<span class="built_in">dfs</span>(each[<span class="number">0</span>],each[<span class="number">1</span>],b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k[a] == <span class="number">0</span> <span class="keyword">or</span> k[b] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> inf</span><br><span class="line">        </span><br><span class="line">    k[tar] = <span class="number">1</span></span><br><span class="line">    #所需种植时间最长以及获得时间最长求和，即为当前种子所需时间</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(time[a],time[b]) + <span class="built_in">max</span>(dp[a],dp[b])</span><br><span class="line"></span><br><span class="line"><span class="meta">#main</span></span><br><span class="line">flag = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="built_in">split</span>()))</span><br><span class="line">time = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="built_in">split</span>()))</span><br><span class="line">have = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="built_in">split</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plan = [[]<span class="keyword">for</span> i in <span class="built_in">range</span>(flag[<span class="number">0</span>]+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(flag[<span class="number">2</span>]):</span><br><span class="line">    num = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="built_in">split</span>()))</span><br><span class="line">    plan[num[<span class="number">-1</span>]].<span class="built_in">append</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="meta">#dp存储获得每个种子所需的最短时间</span></span><br><span class="line">dp = [inf]*(flag[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line"><span class="meta">#k标记已有的种子</span></span><br><span class="line">k = [<span class="number">0</span>]*(flag[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">tar = flag[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">#初始拥有的种子，在dp中的权值为<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each in have:</span><br><span class="line">    dp[each] = <span class="number">0</span></span><br><span class="line">    k[each] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">#遍历每个可以获得目标种子的方案，不断更新dp[tar],取最小</span><br><span class="line"><span class="keyword">for</span> each in plan[tar]:</span><br><span class="line">    dp[tar] =  <span class="built_in">min</span>(dp[tar],<span class="built_in">dfs</span>(each[<span class="number">0</span>],each[<span class="number">1</span>],tar))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[tar])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>解析<br>通过不断的将已有的种子杂交得到新种子，直到得到目标种子是比较麻烦的，因此我们考虑从目标种子开始倒推到已有的种子，好比走迷宫从出口倒着走回到入口。</p>
<p>对输入的进来的杂交方案，使用vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;记录，以第一维下标表示杂交结果，杂交的需要的种子放进pair里，以cost数组记录得到每个种子所需要的最短时间，初始有的种子对应时间为0，而其余初始化为最大值。</p>
<p>从得到目标种子的杂交方案开始往前推，如果需要的种子的最短时间还没确定，则递归计算，这样不断地得到中间过程中每个种子所花费的最短时间，递归结束即得到当前种子所花费的最短时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost, vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;&amp; hybrid, vector&lt;<span class="keyword">int</span>&gt;&amp; t, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hybrid[target].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = hybrid[target][i].first;</span><br><span class="line">        <span class="keyword">int</span> b = hybrid[target][i].second;</span><br><span class="line">        <span class="keyword">if</span> (cost[a] == INT_MAX) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(cost, hybrid, t, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cost[b] == INT_MAX) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(cost, hybrid, t, b);</span><br><span class="line">        &#125;</span><br><span class="line">        cost[target] = <span class="built_in">min</span>(cost[target], <span class="built_in">max</span>(t[a], t[b]) + <span class="built_in">max</span>(cost[a], cost[b]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, K, T;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; T;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(N + <span class="number">1</span>)</span></span>; <span class="comment">//种植时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cost</span><span class="params">(N + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">//花费总时间</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        cost[tmp] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; <span class="built_in">hybrid</span>(N + <span class="number">1</span>); <span class="comment">//杂交方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pa = <span class="built_in">make_pair</span>(a, b);</span><br><span class="line">        hybrid[c].<span class="built_in">push_back</span>(pa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(cost, hybrid, t, T);</span><br><span class="line">    cout &lt;&lt; cost[T] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="http://lx.lanqiao.cn/RequireFile.do?fid=b6V96pY6" alt="p1.png" loading="lazy"></p>
<p>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p>
<p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p>
<h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含一个整数N (1&lt;N≤100)，表示三角形的行数。下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p>
<h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示答案。</p>
<h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0 </span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure>

<p>Data</p>
<h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure>

<h2 id="代码思路："><a href="#代码思路：" class="headerlink" title="代码思路："></a>代码思路：</h2><p>起初做这道题的时候，将题理解为在任何状态下向左走的次数与向右走的次数相差小于1，后面才知道，是最终状态时向左走的次数与向右走的次数相差小于1，则可以定义一个二维数组，行和列都是n+1，从1开始进行赋值，令nums[i][j] += Math.max(nums[i-1][j-1], nums[i-1][j]),最后对n进行判断(因为题目中说明向左和向右的次数相差小于1)，如果n为奇数，则输出中间的那个数即nums[n][n/2],如果n为偶数，则输出中间哪两个较大的数即Math.max(nums[n][n/2] , nums[n][n/2+1])。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.<span class="built_in">nextInt</span>();</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                nums[i][j] = sc.<span class="built_in">nextInt</span>();</span><br><span class="line">                nums[i][j] += Math.<span class="built_in">max</span>(nums[i - <span class="number">1</span>][j - <span class="number">1</span>], nums[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(nums[n][(n + <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(Math.<span class="built_in">max</span>(nums[n][n / <span class="number">2</span>], nums[n][n / <span class="number">2</span> + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="子串分值和"><a href="#子串分值和" class="headerlink" title="子串分值和"></a>子串分值和</h1><p>题目描述<br>对于一个字符串 S，我们定义 S 的分值 f ( S ) 为 S 中出现的不同的字符个数。</p>
<p>例如 f ( “ a b a ” ) = 2，f ( “ a b c ” ) = 3 ，f ( “ a a a ” ) = 1 。</p>
<p>现在给定一个字符串 S [ 0.. n − 1 ] ，请你计算对于所有 S 的非空子串 S [ i . . j ]，f ( S [ i . . j ] ) 的和是多少。</p>
<p>输入格式<br>输入一行包含一个由小写字母组成的字符串 S。</p>
<p>输出格式<br>输出一个整数表示答案。</p>
<p>输入样例<br>ababc</p>
<p>输出样例<br>28</p>
<p>样例解释</p>
<p>子串 f值<br>a     1<br>ab    2<br>aba   2<br>abab  2<br>ababc 3<br> b    1<br> ba   2<br> bab  2<br> babc 3<br>  a   1<br>  ab  2<br>  abc 3<br>   b  1<br>   bc 2<br>    c 1</p>
<p>数据范围<br>对于 20% 的评测用例，1 ≤ n ≤ 10 1 ≤ n ≤ 101≤n≤10；<br>对于 40% 的评测用例，1 ≤ n ≤ 100 1 ≤ n ≤ 1001≤n≤100；<br>对于 50% 的评测用例，1 ≤ n ≤ 1000 1 ≤ n ≤ 10001≤n≤1000；<br>对于 60% 的评测用例，1 ≤ n ≤ 10000 1 ≤ n ≤ 100001≤n≤10000；<br>对于所有评测用例，1 ≤ n ≤ 100000 1 ≤ n ≤ 1000001≤n≤100000。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span><span class="comment">//这是看过一个大佬的写的，改写的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll ans;<span class="comment">//总个数-&gt;定义为long long ,否则会爆</span></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">30</span>][maxn];<span class="comment">//每个字母的id 对应的位置 </span></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">30</span>];<span class="comment">//字母id 对应的数量 </span></span><br><span class="line"><span class="keyword">char</span> a[maxn];<span class="comment">//定义字符数组 </span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">30</span>];<span class="comment">//各个字符区间段位置 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;a+<span class="number">1</span>; <span class="comment">//记得加1 </span></span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;len&lt;&lt;endl; </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		id[a[i]-<span class="string">&#x27;a&#x27;</span>][++cnt[a[i]-<span class="string">&#x27;a&#x27;</span>]]=i;<span class="comment">//字母出现的最后位置 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> front=<span class="number">0</span>;<span class="comment">//统计不同字符数 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)<span class="comment">//26个字母跑一遍 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(id[j][cnt[j]]&gt;=i)<span class="comment">//这个字母在i后面 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t=<span class="built_in">lower_bound</span>(id[j],id[j]+<span class="number">1</span>+cnt[j],i)-id[j];<span class="comment">//就是二分查找</span></span><br><span class="line">				b[++front] =id[j][t];<span class="comment">//不同字符出现的第一个位置 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+front);<span class="comment">//对i后面出现的字母排一下序</span></span><br><span class="line">		<span class="keyword">int</span> last=i;<span class="comment">//当前正在索引的位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=front;j++)<span class="comment">//跑一遍下一个位置 -&gt;其实这里就是第几个不同字符 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans+=(b[j]-last)*(j<span class="number">-1</span>);</span><br><span class="line">			<span class="comment">//b[j]-last是该位字母去上一个字母=距离差 -&gt;其实就是有几个重复的这样的块 </span></span><br><span class="line">			<span class="comment">//然后再 * 这个块的长度,当前字符位置-1，其实就是对前面的做处理</span></span><br><span class="line">			<span class="comment">//只是需要当前这个字符做标志,j-1是除去当前字符，然后将(b[j]-last)个段 *(前面不同字符个数j-1); </span></span><br><span class="line">			last=b[j];<span class="comment">//将索引位置更新 </span></span><br><span class="line">		&#125; </span><br><span class="line">		ans+=(len-last+<span class="number">1</span>)*front; <span class="comment">//最后的位置,就是最长的一个段; </span></span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/%E5%AD%97%E4%B8%B21.png" loading="lazy"></p>
<p><img src="/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/%E5%AD%97%E4%B8%B22.png" loading="lazy"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp法</span></span><br><span class="line"><span class="keyword">char</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line">ll ans;</span><br><span class="line">cin&gt;&gt;a+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">strlen</span>(a+<span class="number">1</span>);i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	dp[i]=dp[i<span class="number">-1</span>]+i-b[a[i]];</span><br><span class="line">  	b[a[i]]=i;</span><br><span class="line">  	ans+=dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="合根植物"><a href="#合根植物" class="headerlink" title="合根植物"></a>合根植物</h1><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：2.0s  内存限制：256.0MB</p>
<h2 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　w星球的一个种植园，被分成 m * n 个小格子（东西方向m行，南北方向n列）。每个格子里种了一株合根植物。<br>　　这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。</p>
<p>　　如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</p>
<h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　第一行，两个整数m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。<br>　　接下来一行，一个整数k，表示下面还有k行数据(0&lt;k&lt;100000)<br>　　接下来k行，第行两个整数a，b，表示编号为a的小格子和编号为b的小格子合根了。</p>
<p>　　格子的编号一行一行，从上到下，从左到右编号。<br>　　比如：5 * 4 的小格子，编号：<br>　　1 2 3 4<br>　　5 6 7 8<br>　　9 10 11 12<br>　　13 14 15 16<br>　　17 18 19 20</p>
<h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 4<br>16<br>2 3<br>1 5<br>5 9<br>4 8<br>7 8<br>9 10<br>10 11<br>11 12<br>10 14<br>12 16<br>14 18<br>17 18<br>15 19<br>19 20<br>9 13<br>13 17</p>
<h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><p>5</p>
<h2 id="样例说明-3"><a href="#样例说明-3" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　其合根情况参考下图<br><img src="http://lx.lanqiao.cn/RequireFile.do?fid=H549d7Ej" alt="img" loading="lazy"></p>
<h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>1、构建一个 m * n + 1 数组，每一个位置初始化为该位置的下标值</p>
<p>2、处理连根情况：<br>注：各个位置的顶层值初始化为其自身<br>如果两个位置的顶层下标值不相同，即这两个位置的还未形成连根，则将第一个值的顶层值所在下标设置为第二值的顶层值的下标，这样一来，就只有第二个值的数值与其下标相同，即形成连根</p>
<p>3、计算连根植物数：<br>只要搜索数组中还有几个数值与其下标相同即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> map[];</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">int</span> m = in.<span class="built_in">nextInt</span>();  <span class="comment">// 行</span></span><br><span class="line">		<span class="keyword">int</span> n = in.<span class="built_in">nextInt</span>();  <span class="comment">// 列</span></span><br><span class="line">		<span class="keyword">int</span> k = in.<span class="built_in">nextInt</span>();  <span class="comment">// 数据量</span></span><br><span class="line">		map = <span class="keyword">new</span> <span class="keyword">int</span>[ m * n + <span class="number">1</span> ];</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++) &#123; <span class="comment">// 数组初始化</span></span><br><span class="line">			map[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;  <span class="comment">// 读入数据，并进行处理</span></span><br><span class="line">			<span class="keyword">int</span> a = in.<span class="built_in">nextInt</span>();</span><br><span class="line">			<span class="keyword">int</span> b = in.<span class="built_in">nextInt</span>();</span><br><span class="line">			<span class="built_in">operate</span>(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(map[i] == i) &#123;</span><br><span class="line">				count ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(count);</span><br><span class="line">		in.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( <span class="built_in">Top</span>(a) != <span class="built_in">Top</span>(b) )</span><br><span class="line">			map[<span class="built_in">Top</span>(a)] = <span class="built_in">Top</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Top</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( map[i] == i ) <span class="keyword">return</span> i;</span><br><span class="line">		map[i] = <span class="built_in">Top</span>(map[i]);</span><br><span class="line">		<span class="keyword">return</span> map[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="分考场"><a href="#分考场" class="headerlink" title="分考场"></a>分考场</h1><h2 id="资源限制-1"><a href="#资源限制-1" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　n个人参加某项特殊考试。<br>　　为了公平，要求任何两个认识的人不能分在同一个考场。<br>　　求是少需要分几个考场才能满足条件。</p>
<h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　第一行，一个整数n(1&lt;n&lt;100)，表示参加考试的人数。<br>　　第二行，一个整数m，表示接下来有m行数据<br>　　以下m行每行的格式为：两个整数a，b，用空格分开 (1&lt;=a,b&lt;=n) 表示第a个人与第b个人认识。</p>
<h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　一行一个整数，表示最少分几个考场。</p>
<h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>8<br>1 2<br>1 3<br>1 4<br>2 3<br>2 4<br>2 5<br>3 4<br>4 5</p>
<h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p>
<h2 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>10<br>1 2<br>1 3<br>1 4<br>1 5<br>2 3<br>2 4<br>2 5<br>3 4<br>3 5<br>4 5</p>
<h2 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h2><p>5</p>
<h2 id="规划-暴力简化版"><a href="#规划-暴力简化版" class="headerlink" title="规划+暴力简化版"></a><strong>规划+暴力简化版</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>整体思想是：所有在刚开始都在第一个房间，然后按照认识人之间的关系从第一个房间到当前分配的最后一个房间进行查找，查找到则将人a(a从1到n)认识的人移出到下个房间，为查找到继续查找，直到查完所有房间结束（结束时该人就默认放到第一个房间）。。。</li>
<li>注意点1： 将认识人关系表按照a&gt;b的关系录入（有助于简化运算，代码已注释，看代码可知）</li>
<li>注意点2：将所有人都默认放到第一个房间，所有人从小到大删选出当前房间。筛选过程：按照关系表里关系，将在当前房间查找到对应关系的人a(a为编号）认识的人b转移到下一个房间，若未查找到人b则在下一个房间继续查找。。。直到查找到当前安排的最后一个房间结束。</li>
<li>我的这个过程有两个问题：</li>
</ul>
<p>\1. 默认规定好了查不到的人放在第一个房间.</p>
<p>\2. a认识的人b只能存放到a的下一个房间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a_b[<span class="number">100</span>][<span class="number">2</span>],r;<span class="comment">//题中所示a_b[]为认识人数组.r为房间数</span></span><br><span class="line"><span class="keyword">int</span> room[<span class="number">100</span>][<span class="number">101</span>];<span class="comment">//[0][0-100]默认为1,即所有人都在[0]房间中，</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//初始化room房间数组</span></span><br><span class="line">&#123;</span><br><span class="line">room[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入认识人数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a_b[i][<span class="number">0</span>]&gt;&gt;a_b[i][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//0位置存储较小值，1位置存储较大值</span></span><br><span class="line"><span class="keyword">if</span>(a_b[i][<span class="number">0</span>]&gt;a_b[i][<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a_b[i][<span class="number">0</span>];</span><br><span class="line">a_b[i][<span class="number">0</span>] = a_b[i][<span class="number">1</span>];</span><br><span class="line">a_b[i][<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//人按序号从小到大</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//认识人列表从前往后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a_b[i][<span class="number">0</span>]==j)<span class="comment">//判断每一对认识人数组中是否是当前最小序号人</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">0</span>;r&lt;n;r++)<span class="comment">//将当前房间中最小序号人认识的人转移到下个房间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*从第一个房间到当前存在的最后一个房间判断a_b[i][0],a_b[i][1]</span></span><br><span class="line"><span class="comment">是不是在同一个房间，是则将两者中较大值a_b[i][1]向下一个房间</span></span><br><span class="line"><span class="comment">转移</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(room[r][a_b[i][<span class="number">0</span>]]==<span class="number">1</span>&amp;&amp;room[r][a_b[i][<span class="number">1</span>]]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">room[r+<span class="number">1</span>][a_b[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">room[r][a_b[i][<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(count!=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(count==n)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(room[r][j]==<span class="number">1</span>)++count;</span><br><span class="line">&#125;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归简化版"><a href="#递归简化版" class="headerlink" title="递归简化版"></a><strong>递归简化版</strong></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li>从第一个人a(a到0到n)开始安排，在当前所有存在的房间查找认识的人。查找到则安排到某房间（该房间不定，因为所有的房间都要尝试一遍，因此采用深度优先遍历思想，查找到某房间符合并安排人a后及时回溯到安排的状态进行下个房间的查找），安排后则安排下个人；没有查找到则查找下个房间。。。</li>
<li>注意事项：该方法仍然可以改进，仅因为此种写法最节省时间（因为我写了几遍并参考网上现有资源，所写的这个代码量最少），因此我展示出来。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//考试人数n,m行数据</span></span><br><span class="line"><span class="keyword">int</span> a_b[<span class="number">500</span>][<span class="number">2</span>];<span class="comment">//认识人关系表</span></span><br><span class="line"><span class="keyword">int</span> rooms[<span class="number">100</span>][<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//房间数</span></span><br><span class="line"><span class="keyword">int</span> r_max = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_max</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> room_s)</span><span class="comment">//当前安排人p，当前安排房间最大值room_s</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r_max&lt;=room_s)<span class="comment">//如果现在安排房间room_s比众多安排房间方案中最小房间r_max大，则结束递归</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p&gt;n)<span class="comment">//如果多于考试人数则结束递归</span></span><br><span class="line">&#123;</span><br><span class="line">r_max = room_s;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;room_s;j++)<span class="comment">//从第一个考试房间查找到当前已经分配的最大值房间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)<span class="comment">//查找m个认识人关系表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*查找认识人关系表中和p认识的人，若该人存在则判断该人是否已经存在此房间，在的话将flag置为零，表示此房间不能安排人p。 */</span></span><br><span class="line"><span class="keyword">if</span>(a_b[i][<span class="number">0</span>]==p&amp;&amp;(rooms[j][a_b[i][<span class="number">1</span>]]==<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a_b[i][<span class="number">1</span>]==p&amp;&amp;(rooms[j][a_b[i][<span class="number">0</span>]]==<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)<span class="comment">//该房间没有查找到和p认识的人则flag=1,可以将p放到该房间。</span></span><br><span class="line">&#123;</span><br><span class="line">rooms[j][p]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">find_max</span>(p+<span class="number">1</span>,room_s);</span><br><span class="line">rooms[j][p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag=<span class="number">1</span>;<span class="comment">//每进一个房间就要把flag初始为1，表示该房间没有认识的人</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述过程房间不满足存放人p，则新开房间安排人p</span></span><br><span class="line">rooms[room_s][p]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">find_max</span>(p+<span class="number">1</span>,room_s+<span class="number">1</span>);</span><br><span class="line">rooms[room_s][p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a_b[i][<span class="number">0</span>]&gt;&gt;a_b[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">find_max</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;r_max&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小数第n位"><a href="#小数第n位" class="headerlink" title="小数第n位"></a>小数第n位</h1><h2 id="资源限制-2"><a href="#资源限制-2" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s  内存限制：256.0MB</p>
<h2 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。<br>　　如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。</p>
<p>　　本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。</p>
<h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&lt;a,b,n&lt;1000000000）</p>
<h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　一行3位数字，表示：a除以b，小数后第n位开始的3位数字。</p>
<h2 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h2><p>1 8 1</p>
<h2 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h2><p>125</p>
<h2 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h2><p>1 8 3</p>
<h2 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h2><p>500</p>
<h2 id="样例输入-13"><a href="#样例输入-13" class="headerlink" title="样例输入"></a>样例输入</h2><p>282866 999000 6</p>
<h2 id="样例输出-13"><a href="#样例输出-13" class="headerlink" title="样例输出"></a>样例输出</h2><p>914</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>为了输出除法的每一位，需要做一下递推，假设被除数和除数分别是a和b，则a/b是他们的整数部分，之后令a = (a%b)*10，可得到下一个小数位的被除数，a/b为该位的小数位，依次类推。</p>
<p>开一个map，记录每次的被除数及其位置，如果要记录的被除数已经存在，则可判断这是一个无限循环小数。记录无限循环小数时可使用start记录循环开始位置，len记录一个循环的长度，当位置index大于等于start时，index位置的小数位等于start+(index-start)%len位置的小数位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//开始循环的位置，循环长度，当前位置</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">-1</span>,len = <span class="number">-1</span>,Count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,n;</span><br><span class="line">map&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; achieved;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>,&amp;a,&amp;b,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> temp = a/b;</span><br><span class="line">	a = (a%b)*<span class="number">10</span>;</span><br><span class="line">	numbers.<span class="built_in">push_back</span>(temp);</span><br><span class="line">	<span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(achieved.<span class="built_in">count</span>(a)!=<span class="number">0</span>)&#123;</span><br><span class="line">			start = achieved[a];</span><br><span class="line">			len = Count-start;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		achieved[a] = Count++;</span><br><span class="line">		temp = a/b;</span><br><span class="line">		numbers.<span class="built_in">push_back</span>(temp);</span><br><span class="line">		a = (a%b)*<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有限小数 </span></span><br><span class="line">	<span class="keyword">if</span>(start == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i&lt;=n+<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;numbers.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,numbers[i]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//无限循环小数 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i&lt;=n+<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;start) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,numbers[i]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,numbers[start+(i-start)%len]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="观光铁路"><a href="#观光铁路" class="headerlink" title="观光铁路"></a>观光铁路</h1><p>资源限制</p>
<p>时间限制：2.0s  内存限制：256.0MB</p>
<p>问题描述</p>
<p>　　跳蚤国正在大力发展旅游业，每个城市都被打造成了旅游景点。<br>　　许多跳蚤想去其他城市旅游，但是由于跳得比较慢，它们的愿望难以实现。这时，小C听说有一种叫做火车的交通工具，在铁路上跑得很快，便抓住了商机，创立了一家铁路公司，向跳蚤国王请示在每两个城市之间都修建铁路。<br>　　然而，由于小C不会扳道岔，火车到一个城市以后只能保证不原路返回，而会随机等概率地驶向与这个城市有铁路连接的另外一个城市。<br>　　跳蚤国王向广大居民征求意见，结果跳蚤们不太满意，因为这样修建铁路以后有可能只游览了3个城市（含出发的城市）以后就回来了，它们希望能多游览几个城市。于是跳蚤国王要求小C提供一个方案，使得每只跳蚤坐上火车后能多游览几个城市才回来。</p>
<p>　　小C提供了一种方案给跳蚤国王。跳蚤国王想知道这个方案中每个城市的居民旅游的期望时间（设火车经过每段铁路的时间都为1），请你来帮跳蚤国王。</p>
<p>输入格式</p>
<p>　　输入的第一行包含两个正整数n、m，其中n表示城市的数量，m表示方案中的铁路条数。<br>　　接下来m行，每行包含两个正整数u、v，表示方案中城市u和城市v之间有一条铁路。<br>　　保证方案中无重边无自环，每两个城市之间都能经过铁路直接或间接到达，且火车由任意一条铁路到任意一个城市以后一定有路可走。</p>
<p>输出格式</p>
<p>　　输出n行，第i行包含一个实数tBi，表示方案B中城市i的居民旅游的期望时间。你应当输出足够多的小数位数，以保证输出的值和真实值之间的绝对或相对误差不超过1e-9。</p>
<p>样例输入</p>
<p>4 5<br>1 2<br>2 3<br>3 4<br>4 1<br>1 3</p>
<p>样例输出</p>
<p>3.333333333333<br>5.000000000000<br>3.333333333333<br>5.000000000000</p>
<p>样例输入</p>
<p>10 15<br>1 2<br>1 9<br>1 5<br>2 3<br>2 7<br>3 4<br>3 10<br>4 5<br>4 8<br>5 6<br>6 7<br>6 10<br>7 8<br>8 9<br>9 10</p>
<p>样例输出</p>
<p>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000<br>10.000000000000</p>
<p>数据规模和约定</p>
<p>　　对于10%的测试点，n &lt;= 10；<br>　　对于20%的测试点，n &lt;= 12；<br>　　对于50%的测试点，n &lt;= 16；<br>　　对于70%的测试点，n &lt;= 19；<br>　　对于100%的测试点，4 &lt;= k &lt;= n &lt;= 21，1 &lt;= u, v &lt;= n。数据有梯度。</p>
<h2 id="并没有解题思路"><a href="#并没有解题思路" class="headerlink" title="并没有解题思路"></a>并没有解题思路</h2><p>这道题我一开始想对于每个点进行一次DFS，在到达边界时（再次回到该点）：累计每条路径经过的边数，路径条数加1。然后该点的期望时间就是总边数/路径条数。</p>
<p>但是做的时候发现我无法保证不会回头，因为是无向边，可能1-&gt;2，然后2-&gt;1，一直死循环下去回不到起点。本来1-&gt;2，那可以通过将该边删去，防止回头，但是因为其他点的路径可能需要这条边，所以不能删去，因此没有想到更好的办法处理。</p>
<p>然后在网上只看到了SPFA算法运用于非最短路问题的解释，并不是很好理解。</p>
<p>后来观察样例发现用每个点的期望时间刚好是：所有点的度数之和/每个点的度数，这样写竟然有65分，不知道是巧合还是的确可以这样统计，期待更好的解答。<br>————————————————<br>版权声明：本文为CSDN博主「邹邹菁菁瑶瑶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40486952/article/details/108947726">https://blog.csdn.net/qq_40486952/article/details/108947726</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 点数，边数</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; child[maxn]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">total</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 计算所有点的度数和</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		sum += child[i].<span class="built_in">size</span>();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 返回x点的度数</span></span><br><span class="line">	<span class="keyword">return</span> child[x].<span class="built_in">size</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">// 顶点编号从1开始 </span></span><br><span class="line">	<span class="comment">// 读入m条无向边 </span></span><br><span class="line">	<span class="keyword">int</span> u, v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		child[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		child[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="built_in">total</span>();</span><br><span class="line">	<span class="keyword">double</span> res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		<span class="comment">// 结果为所有度/某个点的度，为啥？ </span></span><br><span class="line">		res = (<span class="number">1.0</span>*sum)/<span class="built_in">degree</span>(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.12f\n&quot;</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="对局匹配"><a href="#对局匹配" class="headerlink" title="对局匹配"></a>对局匹配</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<p>问题描述</p>
<p>　　小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。</p>
<p>　　小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是K的两名用户匹配在一起。如果两人分差小于或大于K，系统都不会将他们匹配。</p>
<p>　　现在小明知道这个网站总共有N名用户，以及他们的积分分别是A1, A2, … AN。</p>
<p>　　小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来(任意两名用户积分差不等于K)？</p>
<p>输入格式</p>
<p>　　第一行包含两个个整数N和K。<br>　　第二行包含N个整数A1, A2, … AN。</p>
<p>　　对于30%的数据，1 &lt;= N &lt;= 10<br>　　对于100%的数据，1 &lt;= N &lt;= 100000, 0 &lt;= Ai &lt;= 100000, 0 &lt;= K &lt;= 100000</p>
<p>输出格式</p>
<p>　　一个整数，代表答案。</p>
<p>样例输入</p>
<p>10 0<br>1 4 2 8 5 7 1 4 2 8</p>
<p>样例输出</p>
<p>6</p>
<h2 id="思路：贪心"><a href="#思路：贪心" class="headerlink" title="思路：贪心"></a>思路：贪心</h2><p>先找出数列中最多可以组成多少对局。这个可以从小到大贪心扫一遍，然后每个对局取掉一个人，那么答案就是n-ans。</p>
<p>证明:</p>
<p>假设k=1.数列为1,2,3,4,5,6.</p>
<p>显然最大组成3对。如果我们选取(2,3),(4,5)的话，每对去除一个人，那么势必会有两个人会组成新的一对。所以我们需要找出最多组成的对数。</p>
<p>将k变为其它数也是同样的道理。</p>
<p>而寻找最多的对数显然可以从小到大匹配。<br>————————————————<br>版权声明：本文为CSDN博主「哇-WA」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013852115/article/details/83384802">https://blog.csdn.net/u013852115/article/details/83384802</a></p>
<h2 id="题解-dp"><a href="#题解-dp" class="headerlink" title="题解:dp"></a>题解:dp</h2><p>个人觉得这是非常好的一道题目, 题意简洁明了, 却同时考察了多种算法思维.<br>首先第一点不难想到, 首先我们要对积分做一个哈希表的预处理, 也就是把每种积分的数量存好<br>接下来我们考虑对于这样一个分组, 分组中储存所有相差为 k 的种类的数量, 对于这样一个分组相邻的当然就不可取了.<br>于是我们定义d p [ i ] : 前 i 个 分 数 能 取 到 的 最 大 数 量 dp[i]:前i个分数能取到的最大数量dp[i]:前i个分数能取到的最大数量<br>而对于取最大数量, 我们肯定优先取最多的, 而对于每个分组有取和不取两种情况, 即<br>d p [ i ] = m a x ( d p [ i − 1 ] , d p [ i − 1 ] + c u r [ i ] ) dp[i] = max(dp[i-1], dp[i-1]+cur[i])dp[i]=max(dp[i−1],dp[i−1]+cur[i])<br>初始化dp[1] = cur[1], dp[2] = max(dp[1], cur[2])</p>
<p>对于k = 0的情况要特判<br>————————————————<br>版权声明：本文为CSDN博主「Suprit」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1097304791/article/details/90437878">https://blog.csdn.net/a1097304791/article/details/90437878</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(x, n) memset(x,n,sizeof(x));</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];  <span class="comment">//每一类分数的数量</span></span><br><span class="line"><span class="keyword">int</span> cur[maxn];  <span class="comment">//当前构造分组</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];   <span class="comment">//分组中前i种人能取得的最大人数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, len = <span class="number">0</span>, maxA = <span class="number">-1</span>, a;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ++cnt[a];</span><br><span class="line">        maxA = <span class="built_in">max</span>(maxA, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123; <span class="comment">//特判k为0的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxA; ++i)</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123; <span class="comment">//防止漏算</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//构造分组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxA; j+=k)</span><br><span class="line">            cur[++len] = cnt[j];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = cur[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], cur[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= len; ++j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>], dp[j<span class="number">-2</span>]+cur[j]);</span><br><span class="line">        ans += dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="发现环"><a href="#发现环" class="headerlink" title="发现环"></a>发现环</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<p>问题描述</p>
<p>　　小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。</p>
<p>　　不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。</p>
<p>　　为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？</p>
<p>输入格式</p>
<p>　　第一行包含一个整数N。<br>　　以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。</p>
<p>　　对于30%的数据，1 &lt;= N &lt;= 1000<br>　　对于100%的数据, 1 &lt;= N &lt;= 100000， 1 &lt;= a, b &lt;= N</p>
<p>　　输入保证合法。</p>
<p>输出格式</p>
<p>　　按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。</p>
<p>样例输入</p>
<p>5<br>1 2<br>3 1<br>2 4<br>2 5<br>5 3</p>
<p>样例输出</p>
<p>1 2 3 5</p>
<h2 id="解题思路：拓扑排序"><a href="#解题思路：拓扑排序" class="headerlink" title="解题思路：拓扑排序"></a>解题思路：拓扑排序</h2><p>环的问题可以想到拓扑排序，但是本题的边是无向的，表示的时候用双向边表示，原始的拓扑排序解决的是有向无环图，拓扑出入度为0的点，变形为拓扑出入度为1的点，最后剩下的是一个各点入度为2的环。从小到大输出就好了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;vec[<span class="number">100005</span>];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"><span class="keyword">int</span> deg[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i]==<span class="number">1</span>)</span><br><span class="line">        que.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        vis[now]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[now].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( --deg[ vec[now][i] ] == <span class="number">1</span>)</span><br><span class="line">            que.<span class="built_in">push</span>(vec[now][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        vec[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        vec[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        deg[a]++;</span><br><span class="line">        deg[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区间移位"><a href="#区间移位" class="headerlink" title="区间移位"></a>区间移位</h1><p>资源限制</p>
<p>时间限制：1.5s  内存限制：256.0MB</p>
<p>问题描述</p>
<p>　　数轴上有<em>n</em>个闭区间<em>D</em>1,…,<em>Dn</em>。其中区间<em>Di</em>用一对整数[<em>ai</em>, <em>bi</em>]来描述，满足<em>ai</em> &lt; <em>bi</em>。已知这些区间的长度之和至少有10000。所以，通过适当的移动这些区间，你总可以使得他们的“并”覆盖[0, 10000]——也就是说[0, 10000]这个区间内的每一个点都落于至少一个区间内。<br>　　你希望找一个移动方法，使得位移差最大的那个区间的位移量最小。<br>　　具体来说，假设你将<em>Di</em>移动到[<em>ai</em>+<em>ci</em>, <em>bi</em>+<em>ci</em>]这个位置。你希望使得max<em>i</em> |<em>ci</em>|　　最小。</p>
<p>输入格式</p>
<p>　　输入的第一行包含一个整数n，表示区间的数量。<br>　　接下来有n行，每行2个整数ai,　　bi，以一个空格分开，表示区间[<em>ai</em>, <em>bi</em>]。保证区间的长度之和至少是10000。</p>
<p>输出格式</p>
<p>　　输出一个数，表示答案。如果答案是整数，只输出整数部分。如果答案不是整数，输出时四舍五入保留一位小数。</p>
<p>样例输入</p>
<p>2<br>10 5010<br>4980 9980</p>
<p>样例输出</p>
<p>20</p>
<p>样例说明</p>
<p>　　第一个区间往左移动10；第二个区间往右移动20。</p>
<p>样例输入</p>
<p>4<br>0 4000<br>3000 5000<br>5001 8000<br>7000 10000</p>
<p>样例输出</p>
<p>0.5</p>
<p>样例说明</p>
<p>　　第2个区间往右移0.5；第3个区间往左移0.5即可。</p>
<p>数据规模和约定</p>
<p>　　对于30%的评测用例，1 ≤ <em>n</em> ≤ 10；<br>　　对于100%的评测用例，1 ≤ <em>n</em> ≤ 10000，0 ≤ <em>ai</em> &lt; <em>bi</em>　　≤ 10000。</p>
<h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a><strong>解析：</strong></h2><p>刚开始看这题的时候想着按区间的左端点排序，二分答案之后依次枚举，使得区间尽量向右就行了，但是写出来只有80分。</p>
<p>想了想发现，选取最左面的区间并不是最优的，比如[1000,2000]和[1200,1300]两个区间当我们的now（当前覆盖的最右端点 ）是900，二分的答案是300，我们选取第一个区间先向左靠，这是now=1900，此时第二个区间就无法派上用场，但是如果先选取第二个区间再选取第一个区间，now就会变成2300.<br>所以我们得出的结论是在做区间可以到达now的情况下，选取右端点最小的区间。</p>
<h2 id="做法："><a href="#做法：" class="headerlink" title="做法："></a><strong>做法：</strong></h2><p>先将每个区间按照右端点从小到大排序，<br>每个区间活动范围是[l-x,r+x]<br>二分答案之后再二分出满足r+x&gt;=now的右端点最小的区间，然后从这个区间开始依次枚举找到第一个满足l-x&lt;=now的区间，使得区间覆盖now的同时向右靠即可<br>另外值得一提的是小数只能是0.5，因为刚开始区间都是整数，如果一个区间唯一0.4，那么另一个就是0.6，大于0.5.所以为了方便处理，把区间值乘2，最后再除2即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.l=l;</span><br><span class="line">		<span class="keyword">this</span>.r=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(S o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.r!=o.r)</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.r-o.r);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.l-o.l);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> N=<span class="number">20000</span>;</span><br><span class="line">	<span class="keyword">static</span> S[]s=<span class="keyword">new</span> S[<span class="number">10100</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> []vis=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10100</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">int</span> now =<span class="number">0</span>;</span><br><span class="line">		String str=br.readLine();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">			now=now*<span class="number">10</span>+(<span class="keyword">int</span>)(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		n=now;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			now=<span class="number">0</span>;</span><br><span class="line">			str=br.readLine();</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">0</span>,b;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(str.charAt(j)==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">					a=now;</span><br><span class="line">					now=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					now=now*<span class="number">10</span>+(<span class="keyword">int</span>)(str.charAt(j)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			b=now;</span><br><span class="line">			sum+=b-a;</span><br><span class="line">			s[i]=<span class="keyword">new</span> S(a*<span class="number">2</span>,b*<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(s,<span class="number">0</span>,n);</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="comment">//System.out.println(mid);</span></span><br><span class="line">			<span class="keyword">if</span>(check(mid)==<span class="keyword">true</span>) &#123;</span><br><span class="line">				r=mid-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(l/<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(((<span class="keyword">double</span>)(l)*<span class="number">1.0</span>)/<span class="number">2.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10100</span>;i++) &#123;</span><br><span class="line">			vis[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">int</span> l=<span class="number">0</span>,r=n;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">				<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(s[mid].r+x&gt;=now) &#123;</span><br><span class="line">					r=mid-<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;n;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i].l&lt;=x+now&amp;&amp;vis[i]==<span class="number">0</span>) &#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					vis[i]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(now&lt;=s[i].l+x) now+=s[i].r-s[i].l;</span><br><span class="line">					<span class="keyword">else</span> now =s[i].r+x;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;=<span class="number">20000</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="填字母游戏"><a href="#填字母游戏" class="headerlink" title="填字母游戏"></a>填字母游戏</h1><p>资源限制</p>
<p>时间限制：1.0s  内存限制：256.0MB</p>
<p>问题描述</p>
<p>　　小明经常玩 LOL 游戏上瘾，一次他想挑战K大师，不料K大师说：<br>　　“我们先来玩个空格填字母的游戏，要是你不能赢我，就再别玩LOL了”。</p>
<p>　　K大师在纸上画了一行n个格子，要小明和他交替往其中填入字母。</p>
<p>　　并且：</p>
<p>　　1. 轮到某人填的时候，只能在某个空格中填入L或O<br>　　2. 谁先让字母组成了“LOL”的字样，谁获胜。<br>　　3. 如果所有格子都填满了，仍无法组成LOL，则平局。</p>
<p>　　小明试验了几次都输了，他很惭愧，希望你能用计算机帮他解开这个谜。</p>
<p>输入格式</p>
<p>　　第一行，数字n（n&lt;10），表示下面有n个初始局面。<br>　　接下来，n行，每行一个串，表示开始的局面。<br>　　比如：“**<strong><strong>”, 表示有6个空格。“L</strong></strong>”, 表示左边是一个字母L，它的右边是4个空格。</p>
<p>输出格式</p>
<p>　　要求输出n个数字，表示对每个局面，如果小明先填，当K大师总是用最强着法的时候，小明的最好结果。<br>　　1 表示能赢<br>　　-1 表示必输<br>　　0 表示可以逼平</p>
<p>样例输入</p>
<p>4</p>
<hr>
<p>L<strong>L<br>L</strong>L**<em>L<br>L****</em>L</p>
<p>样例输出</p>
<p>0<br>-1<br>1<br>1</p>
<h2 id="方法：博弈树"><a href="#方法：博弈树" class="headerlink" title="方法：博弈树"></a>方法：博弈树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(string &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.count(str)!= <span class="number">0</span>) <span class="keyword">return</span> m[str];</span><br><span class="line">	<span class="keyword">if</span> (str.find(<span class="string">&quot;LOL&quot;</span>) != string::npos) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//对于当前的人来说已经输了</span></span><br><span class="line">	<span class="keyword">if</span> (str.find(<span class="string">&quot;*&quot;</span>) == string::npos) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无位置可下，平了</span></span><br><span class="line">	<span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		str[i] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">		res = max(res, -<span class="number">1</span>*dfs(str));</span><br><span class="line">		str[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (res == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		str[i] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">		res = max(res, -<span class="number">1</span>*dfs(str));</span><br><span class="line">		str[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (res == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	m[str] = res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	vector&lt;string&gt; vec;</span><br><span class="line">	string str;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; str;</span><br><span class="line">		vec.push_back(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cout&lt;&lt;dfs(vec[i])&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法：博弈论"><a href="#方法：博弈论" class="headerlink" title="方法：博弈论"></a>方法：博弈论</h2><p>思路：按照有平局博弈论模版写代码，注意每次返回结果之前要把字符改回去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.<span class="built_in">find</span>(<span class="string">&quot;LOL&quot;</span>) != <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x.<span class="built_in">find</span>(<span class="string">&quot;*&quot;</span>) == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;x[i];i++)</span><br><span class="line">	<span class="keyword">if</span>(x[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">		x[i] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">		res = <span class="built_in">max</span>(res,-<span class="built_in">fun</span>(x));</span><br><span class="line">		<span class="keyword">if</span>(res == <span class="number">1</span>)<span class="keyword">return</span> x[i] = <span class="string">&#x27;*&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">		x[i] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">		res = <span class="built_in">max</span>(res,-<span class="built_in">fun</span>(x));</span><br><span class="line">		x[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		string x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">fun</span>(x) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>诗音</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/" title="蓝桥杯真题综述">https://dawnlight-sion.github.io/2021/05/30/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%98%E7%BB%BC%E8%BF%B0/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2025/05/12/%E7%AE%97%E7%AB%9E%E5%B8%B8%E7%94%A8C++STL%E7%94%A8%E6%B3%95/" rel="prev" title="算竞常用C++STL用法"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">算竞常用C++STL用法</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/05/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E8%A7%A3-%E9%94%99%E8%AF%AF%E7%A5%A8%E6%8D%AE-%E8%BE%93%E5%85%A5%E6%8E%A5%E6%94%B6-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" rel="next" title="蓝桥杯题解-错误票据-输入接收/优先队列"><span class="post-nav-text">蓝桥杯题解-错误票据-输入接收/优先队列</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"></div><style>.utterances {
  max-width: 100%;
}</style><script src="https://utteranc.es/client.js" repo="Dawnlight-Sion/Dawnlight-Sion.github.io" issue-term="title" label="comment" theme="preferred-color-scheme" crossorigin="anonymous" async></script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-lines"></use></svg></span><span class="author"> 诗音</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div><div class="live_time"><span>以密斯特拉之名，魔法降临于此</span><span id="display_live_time"></span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-12-06T22:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>